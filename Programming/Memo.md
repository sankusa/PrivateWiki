※何事もほどほどに。「コストの最小化」という目的を見失わないように。
いい塩梅を体得すべし。

### ☆可読性>保守性・拡張性

### ☆高凝集・低結合

### ☆依存性の整理
>安定した部分に依存を集め、不安定な部分への依存を減らす

### ☆適切な命名
実態でなく目的で命名する。名前から推察される機能と実際の機能が合致すると認知負荷が大幅に下がる。
効果:可読性UP

### 副作用は最小限に

### カプセル化
関連するデータと操作をまとめ、詳細を隠ぺいする。  
効果:結合度DOWN、凝集度UP

### 尋ねるな、命じろ

## SOLID原則
> ### 単一責任原則
> 「クラスが担う責任は、たったひとつに限定すべき」、「クラスを変更する理由は1つのみ」
> 効果:凝集度UP
> ### オープン・クローズド原則(開放・閉鎖原則)
> 「拡張には開かれ、修正には閉じているべき」
> 効果:保守性UP
> ### リスコフの置換原則
> 「S が T の派生型であれば、プログラム内で T 型のオブジェクトが使われている箇所は全て S 型のオブジェクトで置換可能」
> 効果:メリットというか、守らないと複雑化し、ポリモーフィズムにも反する？バグの原因になる
> ### インターフェース分離の原則
> 不要なメンバに依存しなくていいように、適切にインターフェースを分割。
> 効果:凝集度UP、結合度DOWN
> ### 依存性逆転の法則
> 「上位モジュールはいかなるものも下位モジュールから持ち込んではならない。双方とも抽象（例としてインターフェース）に依存するべきである。」  
> 「抽象は詳細に依存してはならない。詳細（具象的な実装内容）が抽象に依存するべきである。」
> 効果:依存方向が統一され、理解しやすく。インターフェースを挟むことで差し替え可能に(テストや変更がしやすい)。保守性、柔軟性UP。正直そんなに大事か？と思っている。

### デメテルの法則=最小知識の原則
「親クラス.子クラス.子クラスのメソッド」みたいな参照をせず、子クラスのアクセサを用意する。  
※結局のところはケースバイケース  

#### クラスを分割する
>関心毎が違う処理が混在していたら分ける  
>ライフサイクルが違う部分は分ける

### DRY原則
重複を避ける。

### 思いつきで共通化しない
あとで別個の処理にしたいとなる可能性を考えておく。

### 不要な拡張性を盛り込まない
「もし○○だったら・・・」はエッジケースのテストについて考えるならOKだが、まだ実装されていない対象について対応するのは間違い。



#### (個人的解釈)間に挟むという考え方
>直接newしたくない→Factoryを作って間に挟む  
>ViewとModelの間にPresenterを挟む

### (個人的解釈)階層構造のクラスは、最上位で意思決定をする

### 参考
[不吉な匂い](http://objectclub.jp/technicaldoc/refactoring/refact-smell)
